<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Blockly Demo: Fixed Blockly</title>
  <script src="./js/blockly_compressed.js"></script>
  <script src="./js/blocks_compressed.js"></script>
  <script src="./js/javascript_compressed.js"></script>
  <script src="./js/msg/js/en.js"></script>
  <script src="./js/pixi.min.js"></script>
  <style>
    body {
      background-color: #fff;
      font-family: sans-serif;
    }
  </style>
</head>

<body>
  <p>
    <button onclick="showCode()">Show JavaScript</button>
    <button onclick="runCode()">Run JavaScript</button>
  </p>

  <div id="blocklyDiv" style="height: 480px; width: 800px;">

    <xml id="toolbox" style="display: none;">
      <block type="actor_down"></block>
      <block type="actor_up"></block>
      <block type="actor_left"></block>
      <block type="actor_right"></block>
    </xml>
  </div>
  <div id="game-view"></div>
  <script>
    let Application = PIXI.Application,
      Container = PIXI.Container,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      TextureCache = PIXI.utils.TextureCache,
      Sprite = PIXI.Sprite,
      Rectangle = PIXI.Rectangle;
    var default_actor = function () {
      actor.vx = 0;
      actor.vy = 0;
    }
    function sleep(numberMillis) {
      var now = new Date();
      var exitTime = now.getTime() + numberMillis;
      while (true) {
        now = new Date();
        if (now.getTime() > exitTime)
          return;
      }
    }
    Blockly.Blocks['actor_down'] = {
      init: function () {
        this.appendDummyInput()
          .appendField('down');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour(160);
        this.setTooltip('Returns number of letters in the provided text.');
        this.setHelpUrl('http://www.w3schools.com/jsref/jsref_length_string.asp');
      }
    };
    Blockly.JavaScript['actor_down'] = function (block) {
      // String or array length.
      var code = "actor.vy = 6;setTimeout(default_actor, 100);";
      return code;
    };
    Blockly.Blocks['actor_up'] = {
      init: function () {
        this.appendDummyInput()
          .appendField('up');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour(160);
        this.setTooltip('Returns number of letters in the provided text.');
        this.setHelpUrl('http://www.w3schools.com/jsref/jsref_length_string.asp');
      }
    };
    Blockly.JavaScript['actor_up'] = function (block) {
      // String or array length.
      var code = "actor.vy = -6;setTimeout(default_actor, 100);";
      return code;
    };
    Blockly.Blocks['actor_left'] = {
      init: function () {
        this.appendDummyInput()
          .appendField('left');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour(160);
        this.setTooltip('Returns number of letters in the provided text.');
        this.setHelpUrl('http://www.w3schools.com/jsref/jsref_length_string.asp');
      }
    };
    Blockly.JavaScript['actor_left'] = function (block) {
      // String or array length.
      var code = "actor.vx = -6;setTimeout(default_actor, 100);";
      return code;
    };
    Blockly.Blocks['actor_right'] = {
      init: function () {
        this.appendDummyInput()
          .appendField('right');

        this.setNextStatement(true);
        this.setPreviousStatement(true);
        this.setColour(160);
        this.setTooltip('Returns number of letters in the provided text.');
        this.setHelpUrl('http://www.w3schools.com/jsref/jsref_length_string.asp');
      }
    };
    Blockly.JavaScript['actor_right'] = function (block) {
      // String or array length.
      var code = "actor.vx = 6;setTimeout(default_actor, 100);";
      return code;
    };

    var demoWorkspace = Blockly.inject('blocklyDiv',
      {
        media: './media/',
        toolbox: document.getElementById('toolbox')
      });

    function showCode() {
      // Generate JavaScript code and display it.
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      var code = Blockly.JavaScript.workspaceToCode(demoWorkspace);
      alert(code);
    }

    function runCode() {
      // Generate JavaScript code and run it.
      window.LoopTrap = 1000;
      Blockly.JavaScript.INFINITE_LOOP_TRAP =
        'if (--window.LoopTrap == 0) throw "Infinite loop.";\n';
      var code = Blockly.JavaScript.workspaceToCode(demoWorkspace);
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      try {
        eval(code);
      } catch (e) {
        alert(e);
      }
    }
    let app = new PIXI.Application({
      width: 512,
      height: 512,
      antialias: true,    // default: false
      transparent: false, // default: false
      resolution: 1       // default: 1

    });
    document.getElementById("game-view").appendChild(app.view);
    PIXI.loader
      .add("./images/explorer.png")
      .add("./images/dungeon.png")
      .add("./images/blob.png")
      .add("./images/treasure.png")
      .load(setup);

    let actor, state, dungeon, treasure, blobs, chimes, exit, player,
      door, healthBar, message, gameScene, gameOverScene, enemies, id;


    //This `setup` function will run when the image has loaded

    function setup() {
      gameScene = new Container();
      app.stage.addChild(gameScene);

      let numberOfBlobs = 8,
        spacing = 48,
        xOffset = 36;

      state = play;
      //Create the cat sprite
      let dungeonTexture = TextureCache["./images/dungeon.png"];
      dungeon = new Sprite(dungeonTexture);
      gameScene.addChild(dungeon);
      let explorerTexture = TextureCache["./images/explorer.png"];
      actor = new Sprite(explorerTexture);
      actor.x = 36;
      actor.y = 36;
      actor.vx = 0;
      actor.vy = 0;
      stete = play;
      gameScene.addChild(actor);

      let blobTexture = TextureCache["./images/blob.png"];

      let treasureTexture = TextureCache["./images/treasure.png"];
      treasure = new Sprite(treasureTexture);
      treasure.x = app.stage.width - treasure.width - 48;
      treasure.y = app.stage.height / 2 - treasure.height / 2;
      gameScene.addChild(treasure);
      for (let i = 0; i < numberOfBlobs; i++) {
        //Make a blob
        let blob = new Sprite(blobTexture);


        //Space each blob horizontally according to the `spacing` value.
        //`xOffset` determines the point from the left of the screen
        //at which the first blob should be added.
        let x = spacing * i + xOffset;

        //Give the blob a random y position
        //(`randomInt` is a custom function - see below)
        let y = randomInt(36, app.stage.height - blob.height - 36);

        //Set the blob's position
        blob.x = x;
        blob.y = y;

        //Add the blob sprite to the stage
        gameScene.addChild(blob);
      }
      app.ticker.add(delta => gameLoop(delta));
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function gameLoop(delta) {
      //Call this `gameLoop` function on the next screen refresh
      //(which happens 60 times per second)

      //Move the cat 1 pixel
      state(delta);
    }
    //gameLoop();

    function play(delta) {
      actor.x += actor.vx;
      actor.y += actor.vy;
    }

  </script>

</body>

</html>